#! /usr/bin/ruby
require 'watir'
require 'nokogiri'
require_relative 'exceptions'

#
class Scrapper
  attr_reader :browser, :authors
  @@endpoints = {
    base: '/', # well structured HTML with microdata markup and pagination buttons
    scroll: '/scroll', # same as /, but with infinite scrolling via AJAX calls.
    random: '/random', #  shows a single random quote.
    login: '/login', #  login page with CSRF token
    search: '/search.aspx', # an AJAX-based filter form that simulates ViewStates behavior.
    js: '/js', # the content is generated by JavaScript code.
    tableful: '/tableful', #  a messed-up layout based on tables.
  }

  def initialize(host = '127.0.0.1', port = 5000, driver = :chrome)
    raise ArgumentError unless [:firefox, :chrome].include?(driver)

    @browser  = Watir::Browser.new(driver)
    @base_url = "http://#{host}:#{port}"
    @authors  = {} # name: about
    @history = {}
  end

  # Uses browser.goto
  # returns: true if url has been changed
  def change_endpoint(endpoint)
    @history[:prev_url] = @browser.url
    @browser.goto(@base_url + @@endpoints[endpoint])
    Watir::Wait.until(timeout: 5) { @history[:prev_url] != @browser.url }
    !@history[:prev_url] == @browser.url
  end

  # Click next || previous button to test pagination
  # returns true if page num in url has been changed
  def change_page(direction)
    raise AttributeError unless [:next, :previous].include?(direction)

    begin
      @history[:prev_page] = %r{\/(\d+)\/$}.match(@browser.url)[1].to_i
    rescue NoMethodError
      @history[:prev_page] = 1
    end
    @browser.li(class: direction.to_s).a.click
    @history[:current_page] = %r{\/(\d+)\/$}.match(@browser.url)[1].to_i

    page_changed?
  end

  # returns true if page num in url differs on 1
  def page_changed?
    1 == (@history[:prev_page] - @history[:current_page]).abs
  end

  # returns array of quotes
  def page_quotes
    @browser.divs(class: 'quote')
  end

  def parse_quote(quote, save_authors = false)
    quote_author           = quote.spans[1].element(class: 'author').text
    @authors[quote_author] = quote.spans[1].a.href if save_authors

    {
      text:   quote.spans[0].text,
      author: quote_author,
      tags:   quote.div.links.map(&:text) # a.k.a { |tag| tag.text }.compact
    }
  end

  def parse_random_quote
    change_endpoint(:random)
    Watir::Wait.until(timeout: 5) { @browser.div(class: 'quote').exists? }
    parse_quote(page_quotes[0])
  end

  def parse_quotes_by_page
    change_endpoint(:base)
    result = []
    loop do
      result.concat(page_quotes.map { |quote| parse_quote(quote) }.compact)
      break unless @browser.li(class: 'next').present?
      change_page(:next)
    end
    result
  end

  def parse_quotes_scroll
    change_endpoint(:scroll)
    result = []
    quotes_on_page = 0
    quotes_after_scroll = 1
    while quotes_on_page != quotes_after_scroll
      quotes_on_page = page_quotes.size
      @browser.driver.execute_script('window.scrollBy(0, document.body.scrollHeight)')
      sleep 1
      quotes_after_scroll = page_quotes.size
    end
    result.concat(page_quotes.map { |quote| parse_quote(quote) }.compact)
  end

  def parse_using_search_ilter(author = 'Mark Twain', tag = 'classic')
    change_endpoint(:search)
    browser.select_list(id: 'author').set(value: author)
    browser.select_list(id: 'tag').set(value: tag)
    browser.button(name: 'submit_button').click
  end

  def login(username, password)
    raise RuntimeError("You're already logged in") if @browser.link(href: '/logout').present?
    change_endpoint(:login)
    @browser.text_field(id: 'username').set(username)
    @browser.text_field(id: 'password').set(password)
    @browser.input(type: 'submit').click

    Watir::Wait.until(timeout: 5) { @browser.link(href: '/logout').present? }
    @browser.link(href: '/logout').present?
  end

  def logout
    raise RuntimeError("You aren't logged in.") if @browser.link(href: '/login').present?
    @browser.link(href: '/logout').click
    Watir::Wait.until(timeout: 5) { @browser.link(href: '/login').present? }
    @browser.link(href: '/login').present?
  end

  def help
    puts "Available methods: #{(methods - self.class.methods).join(', ')}"
  end
end

def run
  scrapper = Scrapper.new
  puts "Logged in: #{scrapper.login('user', 'mySupperPupper#sEcrEt')}"
  puts "Parsed random quote: #{scrapper.parse_random_quote.size == 1}"
  puts "Parsed all quotes using ajax requests for scrolling: #{scrapper.parse_quotes_scroll.size == 100}"
  puts "Parsed all quotes using base page: #{scrapper.parse_quotes_by_page.size == 100}"
  puts "Logged out: #{scrapper.logout}"
  puts "Browser closed: #{scrapper.browser.close}"
end
# while true
#   cmd = gets
#   continue if cmd.empty?
#   cmd = cmd.split(' ')
#   mtd = cmd[0]
#   args = cmd[1].split(',').delete(' ') if cmd.size > 1
#   case mtd
#   when mtd.nil? || mtd.empty?
#     continue
#   when mtd.eql?('exit')
#     break
#   when scrapper.respond_to?(mtd)
#     params_needed = scrapper.method(mtd).parameters.empty?
#     if params_needed
#       scrapper.send(mtd, args)
#     else
#       scrapper.send(mtd)
#     end
#   when scrapper.browser.respond_to?(mtd)
#     params_needed = scrapper.browser.method(mtd).parameters.empty?
#     if params_needed
#       scrapper.browser.send(mtd, args)
#     else
#       scrapper.browser.send(mtd)
#     end
#   end
# end
